// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: multisig/v1/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/codec/types"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgUpdateParams is the Msg/UpdateParams request type.
//
// Since: cosmos-sdk 0.47
type MsgUpdateParams struct {
	// authority is the address of the governance account.
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// params defines the parameters to update.
	//
	// NOTE: All parameters must be supplied.
	Params Params `protobuf:"bytes,2,opt,name=params,proto3" json:"params"`
}

func (m *MsgUpdateParams) Reset()         { *m = MsgUpdateParams{} }
func (m *MsgUpdateParams) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParams) ProtoMessage()    {}
func (*MsgUpdateParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_f023d0392a638bd4, []int{0}
}
func (m *MsgUpdateParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParams.Merge(m, src)
}
func (m *MsgUpdateParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParams proto.InternalMessageInfo

func (m *MsgUpdateParams) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateParams) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

// MsgUpdateParamsResponse defines the response structure for executing a
// MsgUpdateParams message.
//
// Since: cosmos-sdk 0.47
type MsgUpdateParamsResponse struct {
}

func (m *MsgUpdateParamsResponse) Reset()         { *m = MsgUpdateParamsResponse{} }
func (m *MsgUpdateParamsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParamsResponse) ProtoMessage()    {}
func (*MsgUpdateParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f023d0392a638bd4, []int{1}
}
func (m *MsgUpdateParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParamsResponse.Merge(m, src)
}
func (m *MsgUpdateParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParamsResponse proto.InternalMessageInfo

// MsgCreateMultisigAccountParams defines the request type to create a multisig account
type MsgCreateMultisigAccountParams struct {
	Authority  string               `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	Seed       uint32               `protobuf:"varint,2,opt,name=seed,proto3" json:"seed,omitempty"`
	Threshold  uint32               `protobuf:"varint,3,opt,name=threshold,proto3" json:"threshold,omitempty"`
	Signers    [][]byte             `protobuf:"bytes,4,rep,name=signers,proto3" json:"signers,omitempty"`
	Permission MultisigProposalType `protobuf:"varint,5,opt,name=permission,proto3,enum=multisig.v1.MultisigProposalType" json:"permission,omitempty"`
}

func (m *MsgCreateMultisigAccountParams) Reset()         { *m = MsgCreateMultisigAccountParams{} }
func (m *MsgCreateMultisigAccountParams) String() string { return proto.CompactTextString(m) }
func (*MsgCreateMultisigAccountParams) ProtoMessage()    {}
func (*MsgCreateMultisigAccountParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_f023d0392a638bd4, []int{2}
}
func (m *MsgCreateMultisigAccountParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateMultisigAccountParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateMultisigAccountParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateMultisigAccountParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateMultisigAccountParams.Merge(m, src)
}
func (m *MsgCreateMultisigAccountParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateMultisigAccountParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateMultisigAccountParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateMultisigAccountParams proto.InternalMessageInfo

func (m *MsgCreateMultisigAccountParams) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgCreateMultisigAccountParams) GetSeed() uint32 {
	if m != nil {
		return m.Seed
	}
	return 0
}

func (m *MsgCreateMultisigAccountParams) GetThreshold() uint32 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

func (m *MsgCreateMultisigAccountParams) GetSigners() [][]byte {
	if m != nil {
		return m.Signers
	}
	return nil
}

func (m *MsgCreateMultisigAccountParams) GetPermission() MultisigProposalType {
	if m != nil {
		return m.Permission
	}
	return MultisigProposalType_MULTISIG_PROPOSAL_TYPE_UNSPECIFIED
}

// MsgCreateMultisigAccountResponse defines the response structure of a created multisig account operation
type MsgCreateMultisigAccountResponse struct {
	MultisigAddress string `protobuf:"bytes,1,opt,name=multisig_address,json=multisigAddress,proto3" json:"multisig_address,omitempty"`
}

func (m *MsgCreateMultisigAccountResponse) Reset()         { *m = MsgCreateMultisigAccountResponse{} }
func (m *MsgCreateMultisigAccountResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateMultisigAccountResponse) ProtoMessage()    {}
func (*MsgCreateMultisigAccountResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f023d0392a638bd4, []int{3}
}
func (m *MsgCreateMultisigAccountResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateMultisigAccountResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateMultisigAccountResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateMultisigAccountResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateMultisigAccountResponse.Merge(m, src)
}
func (m *MsgCreateMultisigAccountResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateMultisigAccountResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateMultisigAccountResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateMultisigAccountResponse proto.InternalMessageInfo

func (m *MsgCreateMultisigAccountResponse) GetMultisigAddress() string {
	if m != nil {
		return m.MultisigAddress
	}
	return ""
}

// MsgAddMultisigSignerParams defines the request type to add a signer to a multisig account
type MsgAddMultisigSignerParams struct {
	MultisigAddress string `protobuf:"bytes,1,opt,name=multisig_address,json=multisigAddress,proto3" json:"multisig_address,omitempty"`
	Signer          string `protobuf:"bytes,2,opt,name=signer,proto3" json:"signer,omitempty"`
	// Types that are valid to be assigned to XNewThreshold:
	//
	//	*MsgAddMultisigSignerParams_NewThreshold
	XNewThreshold isMsgAddMultisigSignerParams_XNewThreshold `protobuf_oneof:"_new_threshold"`
}

func (m *MsgAddMultisigSignerParams) Reset()         { *m = MsgAddMultisigSignerParams{} }
func (m *MsgAddMultisigSignerParams) String() string { return proto.CompactTextString(m) }
func (*MsgAddMultisigSignerParams) ProtoMessage()    {}
func (*MsgAddMultisigSignerParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_f023d0392a638bd4, []int{4}
}
func (m *MsgAddMultisigSignerParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddMultisigSignerParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddMultisigSignerParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddMultisigSignerParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddMultisigSignerParams.Merge(m, src)
}
func (m *MsgAddMultisigSignerParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddMultisigSignerParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddMultisigSignerParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddMultisigSignerParams proto.InternalMessageInfo

type isMsgAddMultisigSignerParams_XNewThreshold interface {
	isMsgAddMultisigSignerParams_XNewThreshold()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MsgAddMultisigSignerParams_NewThreshold struct {
	NewThreshold uint32 `protobuf:"varint,3,opt,name=new_threshold,json=newThreshold,proto3,oneof" json:"new_threshold,omitempty"`
}

func (*MsgAddMultisigSignerParams_NewThreshold) isMsgAddMultisigSignerParams_XNewThreshold() {}

func (m *MsgAddMultisigSignerParams) GetXNewThreshold() isMsgAddMultisigSignerParams_XNewThreshold {
	if m != nil {
		return m.XNewThreshold
	}
	return nil
}

func (m *MsgAddMultisigSignerParams) GetMultisigAddress() string {
	if m != nil {
		return m.MultisigAddress
	}
	return ""
}

func (m *MsgAddMultisigSignerParams) GetSigner() string {
	if m != nil {
		return m.Signer
	}
	return ""
}

func (m *MsgAddMultisigSignerParams) GetNewThreshold() uint32 {
	if x, ok := m.GetXNewThreshold().(*MsgAddMultisigSignerParams_NewThreshold); ok {
		return x.NewThreshold
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MsgAddMultisigSignerParams) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MsgAddMultisigSignerParams_NewThreshold)(nil),
	}
}

// MsgAddMultisigSignerResponse defines the response structure of adding a signer to a multisig account
type MsgAddMultisigSignerResponse struct {
}

func (m *MsgAddMultisigSignerResponse) Reset()         { *m = MsgAddMultisigSignerResponse{} }
func (m *MsgAddMultisigSignerResponse) String() string { return proto.CompactTextString(m) }
func (*MsgAddMultisigSignerResponse) ProtoMessage()    {}
func (*MsgAddMultisigSignerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f023d0392a638bd4, []int{5}
}
func (m *MsgAddMultisigSignerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddMultisigSignerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddMultisigSignerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddMultisigSignerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddMultisigSignerResponse.Merge(m, src)
}
func (m *MsgAddMultisigSignerResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddMultisigSignerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddMultisigSignerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddMultisigSignerResponse proto.InternalMessageInfo

// MsgCleanupMultisigAccountParams defines the request type to remove all proposals linked to a deleted multisig account
type MsgCleanupMultisigAccountParams struct {
	MultisigAddress string `protobuf:"bytes,1,opt,name=multisig_address,json=multisigAddress,proto3" json:"multisig_address,omitempty"`
}

func (m *MsgCleanupMultisigAccountParams) Reset()         { *m = MsgCleanupMultisigAccountParams{} }
func (m *MsgCleanupMultisigAccountParams) String() string { return proto.CompactTextString(m) }
func (*MsgCleanupMultisigAccountParams) ProtoMessage()    {}
func (*MsgCleanupMultisigAccountParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_f023d0392a638bd4, []int{6}
}
func (m *MsgCleanupMultisigAccountParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCleanupMultisigAccountParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCleanupMultisigAccountParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCleanupMultisigAccountParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCleanupMultisigAccountParams.Merge(m, src)
}
func (m *MsgCleanupMultisigAccountParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgCleanupMultisigAccountParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCleanupMultisigAccountParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCleanupMultisigAccountParams proto.InternalMessageInfo

func (m *MsgCleanupMultisigAccountParams) GetMultisigAddress() string {
	if m != nil {
		return m.MultisigAddress
	}
	return ""
}

// MsgCleanupMultisigAccountResponse defines the response structure of removing a set of proposals linked to a delted multisig account
type MsgCleanupMultisigAccountResponse struct {
}

func (m *MsgCleanupMultisigAccountResponse) Reset()         { *m = MsgCleanupMultisigAccountResponse{} }
func (m *MsgCleanupMultisigAccountResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCleanupMultisigAccountResponse) ProtoMessage()    {}
func (*MsgCleanupMultisigAccountResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f023d0392a638bd4, []int{7}
}
func (m *MsgCleanupMultisigAccountResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCleanupMultisigAccountResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCleanupMultisigAccountResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCleanupMultisigAccountResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCleanupMultisigAccountResponse.Merge(m, src)
}
func (m *MsgCleanupMultisigAccountResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCleanupMultisigAccountResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCleanupMultisigAccountResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCleanupMultisigAccountResponse proto.InternalMessageInfo

// MsgSetMultisigThresholdParams defines the request type to set the threshold for a multisig account
type MsgSetMultisigThresholdParams struct {
	MultisigAddress string `protobuf:"bytes,1,opt,name=multisig_address,json=multisigAddress,proto3" json:"multisig_address,omitempty"`
	Threshold       uint32 `protobuf:"varint,2,opt,name=threshold,proto3" json:"threshold,omitempty"`
}

func (m *MsgSetMultisigThresholdParams) Reset()         { *m = MsgSetMultisigThresholdParams{} }
func (m *MsgSetMultisigThresholdParams) String() string { return proto.CompactTextString(m) }
func (*MsgSetMultisigThresholdParams) ProtoMessage()    {}
func (*MsgSetMultisigThresholdParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_f023d0392a638bd4, []int{8}
}
func (m *MsgSetMultisigThresholdParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetMultisigThresholdParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetMultisigThresholdParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetMultisigThresholdParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetMultisigThresholdParams.Merge(m, src)
}
func (m *MsgSetMultisigThresholdParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetMultisigThresholdParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetMultisigThresholdParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetMultisigThresholdParams proto.InternalMessageInfo

func (m *MsgSetMultisigThresholdParams) GetMultisigAddress() string {
	if m != nil {
		return m.MultisigAddress
	}
	return ""
}

func (m *MsgSetMultisigThresholdParams) GetThreshold() uint32 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

// MsgSetMultisigThresholdResponse defines the response structure of setting a threshold for a multisig account
type MsgSetMultisigThresholdResponse struct {
}

func (m *MsgSetMultisigThresholdResponse) Reset()         { *m = MsgSetMultisigThresholdResponse{} }
func (m *MsgSetMultisigThresholdResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetMultisigThresholdResponse) ProtoMessage()    {}
func (*MsgSetMultisigThresholdResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f023d0392a638bd4, []int{9}
}
func (m *MsgSetMultisigThresholdResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetMultisigThresholdResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetMultisigThresholdResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetMultisigThresholdResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetMultisigThresholdResponse.Merge(m, src)
}
func (m *MsgSetMultisigThresholdResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetMultisigThresholdResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetMultisigThresholdResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetMultisigThresholdResponse proto.InternalMessageInfo

// MsgInitializeMultisigProposalParams defines the request type to initialize a multisig proposal
type MsgInitializeMultisigProposalParams struct {
	MultisigAddress string     `protobuf:"bytes,1,opt,name=multisig_address,json=multisigAddress,proto3" json:"multisig_address,omitempty"`
	Proposer        string     `protobuf:"bytes,2,opt,name=proposer,proto3" json:"proposer,omitempty"`
	Title           string     `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	Description     string     `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	Message         *types.Any `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *MsgInitializeMultisigProposalParams) Reset()         { *m = MsgInitializeMultisigProposalParams{} }
func (m *MsgInitializeMultisigProposalParams) String() string { return proto.CompactTextString(m) }
func (*MsgInitializeMultisigProposalParams) ProtoMessage()    {}
func (*MsgInitializeMultisigProposalParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_f023d0392a638bd4, []int{10}
}
func (m *MsgInitializeMultisigProposalParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgInitializeMultisigProposalParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgInitializeMultisigProposalParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgInitializeMultisigProposalParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgInitializeMultisigProposalParams.Merge(m, src)
}
func (m *MsgInitializeMultisigProposalParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgInitializeMultisigProposalParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgInitializeMultisigProposalParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgInitializeMultisigProposalParams proto.InternalMessageInfo

func (m *MsgInitializeMultisigProposalParams) GetMultisigAddress() string {
	if m != nil {
		return m.MultisigAddress
	}
	return ""
}

func (m *MsgInitializeMultisigProposalParams) GetProposer() string {
	if m != nil {
		return m.Proposer
	}
	return ""
}

func (m *MsgInitializeMultisigProposalParams) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *MsgInitializeMultisigProposalParams) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MsgInitializeMultisigProposalParams) GetMessage() *types.Any {
	if m != nil {
		return m.Message
	}
	return nil
}

// MsgInitializeMultisigResponse defines the response structure of initializing a multisig proposal
type MsgInitializeMultisigResponse struct {
	ProposalId uint64 `protobuf:"varint,1,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
}

func (m *MsgInitializeMultisigResponse) Reset()         { *m = MsgInitializeMultisigResponse{} }
func (m *MsgInitializeMultisigResponse) String() string { return proto.CompactTextString(m) }
func (*MsgInitializeMultisigResponse) ProtoMessage()    {}
func (*MsgInitializeMultisigResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f023d0392a638bd4, []int{11}
}
func (m *MsgInitializeMultisigResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgInitializeMultisigResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgInitializeMultisigResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgInitializeMultisigResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgInitializeMultisigResponse.Merge(m, src)
}
func (m *MsgInitializeMultisigResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgInitializeMultisigResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgInitializeMultisigResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgInitializeMultisigResponse proto.InternalMessageInfo

func (m *MsgInitializeMultisigResponse) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

// MsgApproveMultisigProposalParams defines the request type to approve a multisig proposal
type MsgApproveMultisigProposalParams struct {
	MultisigAddress string `protobuf:"bytes,1,opt,name=multisig_address,json=multisigAddress,proto3" json:"multisig_address,omitempty"`
	ProposalId      uint64 `protobuf:"varint,2,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	Approver        string `protobuf:"bytes,3,opt,name=approver,proto3" json:"approver,omitempty"`
}

func (m *MsgApproveMultisigProposalParams) Reset()         { *m = MsgApproveMultisigProposalParams{} }
func (m *MsgApproveMultisigProposalParams) String() string { return proto.CompactTextString(m) }
func (*MsgApproveMultisigProposalParams) ProtoMessage()    {}
func (*MsgApproveMultisigProposalParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_f023d0392a638bd4, []int{12}
}
func (m *MsgApproveMultisigProposalParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgApproveMultisigProposalParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgApproveMultisigProposalParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgApproveMultisigProposalParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgApproveMultisigProposalParams.Merge(m, src)
}
func (m *MsgApproveMultisigProposalParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgApproveMultisigProposalParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgApproveMultisigProposalParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgApproveMultisigProposalParams proto.InternalMessageInfo

func (m *MsgApproveMultisigProposalParams) GetMultisigAddress() string {
	if m != nil {
		return m.MultisigAddress
	}
	return ""
}

func (m *MsgApproveMultisigProposalParams) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

func (m *MsgApproveMultisigProposalParams) GetApprover() string {
	if m != nil {
		return m.Approver
	}
	return ""
}

// MsgApproveMultisigProposalResponse defines the response structure of approving a multisig proposal
type MsgApproveMultisigProposalResponse struct {
}

func (m *MsgApproveMultisigProposalResponse) Reset()         { *m = MsgApproveMultisigProposalResponse{} }
func (m *MsgApproveMultisigProposalResponse) String() string { return proto.CompactTextString(m) }
func (*MsgApproveMultisigProposalResponse) ProtoMessage()    {}
func (*MsgApproveMultisigProposalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f023d0392a638bd4, []int{13}
}
func (m *MsgApproveMultisigProposalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgApproveMultisigProposalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgApproveMultisigProposalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgApproveMultisigProposalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgApproveMultisigProposalResponse.Merge(m, src)
}
func (m *MsgApproveMultisigProposalResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgApproveMultisigProposalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgApproveMultisigProposalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgApproveMultisigProposalResponse proto.InternalMessageInfo

// MsgApproveMultisigProposalParams defines the request type to approve a multisig proposal
type MsgApproveAndDispatchMultisigProposalParams struct {
	MultisigAddress string     `protobuf:"bytes,1,opt,name=multisig_address,json=multisigAddress,proto3" json:"multisig_address,omitempty"`
	ProposalId      uint64     `protobuf:"varint,2,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	Approver        string     `protobuf:"bytes,3,opt,name=approver,proto3" json:"approver,omitempty"`
	Message         *types.Any `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *MsgApproveAndDispatchMultisigProposalParams) Reset() {
	*m = MsgApproveAndDispatchMultisigProposalParams{}
}
func (m *MsgApproveAndDispatchMultisigProposalParams) String() string {
	return proto.CompactTextString(m)
}
func (*MsgApproveAndDispatchMultisigProposalParams) ProtoMessage() {}
func (*MsgApproveAndDispatchMultisigProposalParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_f023d0392a638bd4, []int{14}
}
func (m *MsgApproveAndDispatchMultisigProposalParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgApproveAndDispatchMultisigProposalParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgApproveAndDispatchMultisigProposalParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgApproveAndDispatchMultisigProposalParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgApproveAndDispatchMultisigProposalParams.Merge(m, src)
}
func (m *MsgApproveAndDispatchMultisigProposalParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgApproveAndDispatchMultisigProposalParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgApproveAndDispatchMultisigProposalParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgApproveAndDispatchMultisigProposalParams proto.InternalMessageInfo

func (m *MsgApproveAndDispatchMultisigProposalParams) GetMultisigAddress() string {
	if m != nil {
		return m.MultisigAddress
	}
	return ""
}

func (m *MsgApproveAndDispatchMultisigProposalParams) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

func (m *MsgApproveAndDispatchMultisigProposalParams) GetApprover() string {
	if m != nil {
		return m.Approver
	}
	return ""
}

func (m *MsgApproveAndDispatchMultisigProposalParams) GetMessage() *types.Any {
	if m != nil {
		return m.Message
	}
	return nil
}

// MsgApproveMultisigProposalResponse defines the response structure of approving a multisig proposal
type MsgApproveAndDispatchMultisigProposalResponse struct {
	TransactionHash string `protobuf:"bytes,1,opt,name=transaction_hash,json=transactionHash,proto3" json:"transaction_hash,omitempty"`
}

func (m *MsgApproveAndDispatchMultisigProposalResponse) Reset() {
	*m = MsgApproveAndDispatchMultisigProposalResponse{}
}
func (m *MsgApproveAndDispatchMultisigProposalResponse) String() string {
	return proto.CompactTextString(m)
}
func (*MsgApproveAndDispatchMultisigProposalResponse) ProtoMessage() {}
func (*MsgApproveAndDispatchMultisigProposalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f023d0392a638bd4, []int{15}
}
func (m *MsgApproveAndDispatchMultisigProposalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgApproveAndDispatchMultisigProposalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgApproveAndDispatchMultisigProposalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgApproveAndDispatchMultisigProposalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgApproveAndDispatchMultisigProposalResponse.Merge(m, src)
}
func (m *MsgApproveAndDispatchMultisigProposalResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgApproveAndDispatchMultisigProposalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgApproveAndDispatchMultisigProposalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgApproveAndDispatchMultisigProposalResponse proto.InternalMessageInfo

func (m *MsgApproveAndDispatchMultisigProposalResponse) GetTransactionHash() string {
	if m != nil {
		return m.TransactionHash
	}
	return ""
}

// MsgCancelMultisigProposalParams defines the request type to reject a multisig proposal
type MsgCancelMultisigProposalParams struct {
	MultisigAddress string `protobuf:"bytes,1,opt,name=multisig_address,json=multisigAddress,proto3" json:"multisig_address,omitempty"`
	ProposalId      uint64 `protobuf:"varint,2,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	Rejecter        string `protobuf:"bytes,3,opt,name=rejecter,proto3" json:"rejecter,omitempty"`
}

func (m *MsgCancelMultisigProposalParams) Reset()         { *m = MsgCancelMultisigProposalParams{} }
func (m *MsgCancelMultisigProposalParams) String() string { return proto.CompactTextString(m) }
func (*MsgCancelMultisigProposalParams) ProtoMessage()    {}
func (*MsgCancelMultisigProposalParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_f023d0392a638bd4, []int{16}
}
func (m *MsgCancelMultisigProposalParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelMultisigProposalParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelMultisigProposalParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelMultisigProposalParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelMultisigProposalParams.Merge(m, src)
}
func (m *MsgCancelMultisigProposalParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelMultisigProposalParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelMultisigProposalParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelMultisigProposalParams proto.InternalMessageInfo

func (m *MsgCancelMultisigProposalParams) GetMultisigAddress() string {
	if m != nil {
		return m.MultisigAddress
	}
	return ""
}

func (m *MsgCancelMultisigProposalParams) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

func (m *MsgCancelMultisigProposalParams) GetRejecter() string {
	if m != nil {
		return m.Rejecter
	}
	return ""
}

// MsgCancelMultisigProposalResponse defines the response structure of rejecting a multisig proposal
type MsgCancelMultisigProposalResponse struct {
}

func (m *MsgCancelMultisigProposalResponse) Reset()         { *m = MsgCancelMultisigProposalResponse{} }
func (m *MsgCancelMultisigProposalResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCancelMultisigProposalResponse) ProtoMessage()    {}
func (*MsgCancelMultisigProposalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f023d0392a638bd4, []int{17}
}
func (m *MsgCancelMultisigProposalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelMultisigProposalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelMultisigProposalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelMultisigProposalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelMultisigProposalResponse.Merge(m, src)
}
func (m *MsgCancelMultisigProposalResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelMultisigProposalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelMultisigProposalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelMultisigProposalResponse proto.InternalMessageInfo

// MsgCleanupMultisigProposalParams defines the request type to clear all multisig proposals after account deletion
type MsgCleanupMultisigProposalParams struct {
	MultisigAddress string `protobuf:"bytes,1,opt,name=multisig_address,json=multisigAddress,proto3" json:"multisig_address,omitempty"`
	ProposalId      uint64 `protobuf:"varint,2,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id,omitempty"`
	Remover         string `protobuf:"bytes,3,opt,name=remover,proto3" json:"remover,omitempty"`
}

func (m *MsgCleanupMultisigProposalParams) Reset()         { *m = MsgCleanupMultisigProposalParams{} }
func (m *MsgCleanupMultisigProposalParams) String() string { return proto.CompactTextString(m) }
func (*MsgCleanupMultisigProposalParams) ProtoMessage()    {}
func (*MsgCleanupMultisigProposalParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_f023d0392a638bd4, []int{18}
}
func (m *MsgCleanupMultisigProposalParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCleanupMultisigProposalParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCleanupMultisigProposalParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCleanupMultisigProposalParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCleanupMultisigProposalParams.Merge(m, src)
}
func (m *MsgCleanupMultisigProposalParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgCleanupMultisigProposalParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCleanupMultisigProposalParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCleanupMultisigProposalParams proto.InternalMessageInfo

func (m *MsgCleanupMultisigProposalParams) GetMultisigAddress() string {
	if m != nil {
		return m.MultisigAddress
	}
	return ""
}

func (m *MsgCleanupMultisigProposalParams) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

func (m *MsgCleanupMultisigProposalParams) GetRemover() string {
	if m != nil {
		return m.Remover
	}
	return ""
}

// MsgCleanupMultisigProposalResponse defines the response structure of removed proposal of deleted multisig account
type MsgCleanupMultisigProposalResponse struct {
}

func (m *MsgCleanupMultisigProposalResponse) Reset()         { *m = MsgCleanupMultisigProposalResponse{} }
func (m *MsgCleanupMultisigProposalResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCleanupMultisigProposalResponse) ProtoMessage()    {}
func (*MsgCleanupMultisigProposalResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f023d0392a638bd4, []int{19}
}
func (m *MsgCleanupMultisigProposalResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCleanupMultisigProposalResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCleanupMultisigProposalResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCleanupMultisigProposalResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCleanupMultisigProposalResponse.Merge(m, src)
}
func (m *MsgCleanupMultisigProposalResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCleanupMultisigProposalResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCleanupMultisigProposalResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCleanupMultisigProposalResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgUpdateParams)(nil), "multisig.v1.MsgUpdateParams")
	proto.RegisterType((*MsgUpdateParamsResponse)(nil), "multisig.v1.MsgUpdateParamsResponse")
	proto.RegisterType((*MsgCreateMultisigAccountParams)(nil), "multisig.v1.MsgCreateMultisigAccountParams")
	proto.RegisterType((*MsgCreateMultisigAccountResponse)(nil), "multisig.v1.MsgCreateMultisigAccountResponse")
	proto.RegisterType((*MsgAddMultisigSignerParams)(nil), "multisig.v1.MsgAddMultisigSignerParams")
	proto.RegisterType((*MsgAddMultisigSignerResponse)(nil), "multisig.v1.MsgAddMultisigSignerResponse")
	proto.RegisterType((*MsgCleanupMultisigAccountParams)(nil), "multisig.v1.MsgCleanupMultisigAccountParams")
	proto.RegisterType((*MsgCleanupMultisigAccountResponse)(nil), "multisig.v1.MsgCleanupMultisigAccountResponse")
	proto.RegisterType((*MsgSetMultisigThresholdParams)(nil), "multisig.v1.MsgSetMultisigThresholdParams")
	proto.RegisterType((*MsgSetMultisigThresholdResponse)(nil), "multisig.v1.MsgSetMultisigThresholdResponse")
	proto.RegisterType((*MsgInitializeMultisigProposalParams)(nil), "multisig.v1.MsgInitializeMultisigProposalParams")
	proto.RegisterType((*MsgInitializeMultisigResponse)(nil), "multisig.v1.MsgInitializeMultisigResponse")
	proto.RegisterType((*MsgApproveMultisigProposalParams)(nil), "multisig.v1.MsgApproveMultisigProposalParams")
	proto.RegisterType((*MsgApproveMultisigProposalResponse)(nil), "multisig.v1.MsgApproveMultisigProposalResponse")
	proto.RegisterType((*MsgApproveAndDispatchMultisigProposalParams)(nil), "multisig.v1.MsgApproveAndDispatchMultisigProposalParams")
	proto.RegisterType((*MsgApproveAndDispatchMultisigProposalResponse)(nil), "multisig.v1.MsgApproveAndDispatchMultisigProposalResponse")
	proto.RegisterType((*MsgCancelMultisigProposalParams)(nil), "multisig.v1.MsgCancelMultisigProposalParams")
	proto.RegisterType((*MsgCancelMultisigProposalResponse)(nil), "multisig.v1.MsgCancelMultisigProposalResponse")
	proto.RegisterType((*MsgCleanupMultisigProposalParams)(nil), "multisig.v1.MsgCleanupMultisigProposalParams")
	proto.RegisterType((*MsgCleanupMultisigProposalResponse)(nil), "multisig.v1.MsgCleanupMultisigProposalResponse")
}

func init() { proto.RegisterFile("multisig/v1/tx.proto", fileDescriptor_f023d0392a638bd4) }

var fileDescriptor_f023d0392a638bd4 = []byte{
	// 1055 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x57, 0xbf, 0x6f, 0xdb, 0x46,
	0x14, 0x16, 0x65, 0xd9, 0xae, 0x9e, 0x1c, 0xdb, 0xbd, 0x2a, 0xb5, 0xc2, 0xba, 0xb2, 0xcc, 0x04,
	0xa8, 0xe2, 0x44, 0x64, 0xa4, 0x16, 0x41, 0x91, 0xa9, 0x52, 0x32, 0x24, 0x28, 0x04, 0x18, 0x74,
	0xba, 0x64, 0x11, 0x4e, 0xe2, 0x85, 0x64, 0x21, 0xfe, 0x00, 0xef, 0xa4, 0x44, 0x99, 0xda, 0x4c,
	0x1d, 0x3a, 0x74, 0xea, 0xd0, 0xbd, 0x9d, 0x33, 0x64, 0x6c, 0x3b, 0x07, 0x5d, 0x1a, 0x74, 0xea,
	0x54, 0x14, 0xf6, 0x90, 0x7f, 0xa3, 0x10, 0x7f, 0x9c, 0x25, 0x4a, 0xa4, 0x54, 0x54, 0x85, 0x91,
	0x8d, 0x77, 0xef, 0xbb, 0xf7, 0xde, 0x7d, 0xf7, 0xdd, 0xbb, 0x47, 0x28, 0x5a, 0x83, 0x3e, 0x33,
	0xa9, 0xa9, 0x2b, 0xc3, 0xba, 0xc2, 0x9e, 0xca, 0xae, 0xe7, 0x30, 0x07, 0x15, 0xa2, 0x59, 0x79,
	0x58, 0x17, 0xf7, 0x7a, 0x0e, 0xb5, 0x1c, 0xaa, 0x58, 0xd4, 0x07, 0x59, 0x54, 0x0f, 0x50, 0xe2,
	0x15, 0xdd, 0x71, 0xf4, 0x3e, 0x51, 0xfc, 0x51, 0x77, 0xf0, 0x58, 0xc1, 0xf6, 0x28, 0x32, 0x4d,
	0xba, 0xd5, 0x89, 0x4d, 0xa8, 0x49, 0x43, 0xd3, 0xde, 0xa4, 0x89, 0x32, 0xcc, 0x48, 0x68, 0x28,
	0xea, 0x8e, 0xee, 0xf8, 0x9f, 0xca, 0xf8, 0x2b, 0xf2, 0x14, 0x44, 0xef, 0x04, 0x86, 0x60, 0x10,
	0x98, 0xa4, 0x6f, 0x05, 0xd8, 0x69, 0x53, 0xfd, 0x0b, 0x57, 0xc3, 0x8c, 0x1c, 0x63, 0x0f, 0x5b,
	0x14, 0xdd, 0x86, 0x3c, 0x1e, 0x30, 0xc3, 0xf1, 0x4c, 0x36, 0x2a, 0x09, 0x15, 0xa1, 0x9a, 0x6f,
	0x95, 0xfe, 0x78, 0x59, 0x2b, 0x86, 0x0b, 0x9b, 0x9a, 0xe6, 0x11, 0x4a, 0x4f, 0x98, 0x67, 0xda,
	0xba, 0x7a, 0x0e, 0x45, 0x75, 0xd8, 0x70, 0x7d, 0x0f, 0xa5, 0x6c, 0x45, 0xa8, 0x16, 0x1a, 0xef,
	0xc9, 0x13, 0x14, 0xc8, 0x81, 0xf3, 0x56, 0xee, 0xd5, 0x5f, 0x07, 0x19, 0x35, 0x04, 0xde, 0xd9,
	0x7e, 0xfe, 0xe6, 0xc5, 0xd1, 0xb9, 0x0b, 0xe9, 0x0a, 0xec, 0xc5, 0xb2, 0x51, 0x09, 0x75, 0x1d,
	0x9b, 0x12, 0xe9, 0xeb, 0x2c, 0x94, 0xdb, 0x54, 0xbf, 0xeb, 0x11, 0xcc, 0x48, 0x3b, 0x74, 0xdc,
	0xec, 0xf5, 0x9c, 0x81, 0xcd, 0xfe, 0x63, 0xe2, 0x08, 0x72, 0x94, 0x10, 0xcd, 0x4f, 0xfb, 0x92,
	0xea, 0x7f, 0xa3, 0x7d, 0xc8, 0x33, 0xc3, 0x23, 0xd4, 0x70, 0xfa, 0x5a, 0x69, 0xcd, 0x37, 0x9c,
	0x4f, 0xa0, 0x06, 0x6c, 0x52, 0x53, 0xb7, 0x89, 0x47, 0x4b, 0xb9, 0xca, 0x5a, 0x75, 0x2b, 0x25,
	0x4e, 0x04, 0x44, 0x4d, 0x00, 0x97, 0x78, 0x96, 0x49, 0xa9, 0xe9, 0xd8, 0xa5, 0xf5, 0x8a, 0x50,
	0xdd, 0x6e, 0x1c, 0x4e, 0x51, 0x14, 0xed, 0xea, 0xd8, 0x73, 0x5c, 0x87, 0xe2, 0xfe, 0xc3, 0x91,
	0x4b, 0xd4, 0x89, 0x45, 0x92, 0x0e, 0x95, 0x24, 0x0a, 0x22, 0x9e, 0xd0, 0x5d, 0xd8, 0x8d, 0x7c,
	0x76, 0x70, 0x90, 0xc9, 0x42, 0x2e, 0x76, 0xa2, 0x15, 0xe1, 0xb4, 0xf4, 0xbb, 0x00, 0x62, 0x9b,
	0x8e, 0x87, 0x51, 0x98, 0x13, 0x7f, 0x17, 0x21, 0xd1, 0xab, 0x88, 0x81, 0x6e, 0xc1, 0x46, 0x40,
	0x8d, 0xcf, 0x7b, 0xda, 0xd2, 0x10, 0x87, 0xaa, 0x70, 0xc9, 0x26, 0x4f, 0x3a, 0xb1, 0x73, 0xb9,
	0x9f, 0x51, 0xb7, 0x6c, 0xf2, 0xe4, 0x61, 0x34, 0xfb, 0x8d, 0x20, 0xb4, 0x76, 0x61, 0xbb, 0x33,
	0x05, 0x95, 0xca, 0xb0, 0x3f, 0x6f, 0x43, 0x5c, 0x5e, 0x8f, 0xe1, 0x60, 0x4c, 0x6d, 0x9f, 0x60,
	0x7b, 0xe0, 0xce, 0x97, 0xd7, 0x4a, 0x98, 0xbd, 0x0a, 0x87, 0x89, 0x71, 0x78, 0x32, 0xcf, 0x05,
	0xf8, 0xb0, 0x4d, 0xf5, 0x13, 0xc2, 0x22, 0x04, 0xdf, 0xdd, 0x2a, 0x4f, 0x60, 0x4a, 0xe3, 0xd9,
	0x98, 0xc6, 0xa5, 0x43, 0x9f, 0x91, 0x79, 0x39, 0xf0, 0x3c, 0x7f, 0xcc, 0xc2, 0xd5, 0x36, 0xd5,
	0x1f, 0xd8, 0x26, 0x33, 0x71, 0xdf, 0x7c, 0x46, 0xe2, 0x0a, 0x5e, 0x65, 0xb6, 0x9f, 0xc0, 0x3b,
	0xae, 0xef, 0x76, 0x09, 0xc5, 0x70, 0x24, 0x2a, 0xc2, 0x3a, 0x33, 0x59, 0x9f, 0xf8, 0x5a, 0xc9,
	0xab, 0xc1, 0x00, 0x55, 0xa0, 0xa0, 0x11, 0xda, 0xf3, 0x4c, 0x97, 0x8d, 0x2f, 0x63, 0xce, 0xb7,
	0x4d, 0x4e, 0xa1, 0xcf, 0x61, 0xd3, 0x22, 0x94, 0x62, 0x9d, 0xf8, 0x57, 0xb5, 0xd0, 0x28, 0xca,
	0x41, 0xa9, 0x96, 0xa3, 0x52, 0x2d, 0x37, 0xed, 0x51, 0xeb, 0x83, 0xdf, 0x5e, 0xd6, 0xc2, 0xe2,
	0x2e, 0x77, 0x31, 0x25, 0xf2, 0xb0, 0xde, 0x25, 0x0c, 0xd7, 0xe5, 0x36, 0xd5, 0xd5, 0xc8, 0x83,
	0xf4, 0x99, 0x7f, 0x9c, 0xb3, 0x34, 0xf1, 0x4b, 0x7b, 0x00, 0x05, 0x37, 0xa4, 0xac, 0x63, 0x6a,
	0x3e, 0x37, 0x39, 0x15, 0xa2, 0xa9, 0x07, 0x9a, 0xf4, 0xab, 0xe0, 0x5f, 0xfd, 0xa6, 0xeb, 0x7a,
	0xce, 0xf0, 0x7f, 0xa5, 0x39, 0x96, 0x4a, 0x36, 0x9e, 0xca, 0xf8, 0x1c, 0x70, 0x90, 0x86, 0x17,
	0x90, 0x9a, 0x76, 0x0e, 0x11, 0x52, 0xba, 0x06, 0x52, 0x72, 0xfe, 0x5c, 0x50, 0xdf, 0x67, 0xe1,
	0xc6, 0x39, 0xac, 0x69, 0x6b, 0xf7, 0x4c, 0xea, 0x62, 0xd6, 0x33, 0xde, 0xbe, 0x1d, 0xaf, 0x56,
	0x41, 0x8f, 0xa0, 0xb6, 0x14, 0x2f, 0x5c, 0x51, 0xd7, 0x61, 0x97, 0x79, 0xd8, 0xa6, 0xb8, 0x37,
	0x96, 0x73, 0xc7, 0xc0, 0xd4, 0x08, 0x98, 0x51, 0x77, 0x26, 0xe6, 0xef, 0x63, 0x6a, 0x48, 0xbf,
	0x08, 0x41, 0xed, 0xc3, 0x76, 0x8f, 0xf4, 0x2f, 0x9a, 0x68, 0x8f, 0x7c, 0x49, 0x7a, 0x6c, 0x19,
	0xa2, 0x23, 0x64, 0x54, 0x52, 0xe7, 0xa6, 0xcf, 0x95, 0xf5, 0x73, 0x70, 0x81, 0x62, 0x85, 0xf7,
	0x42, 0x76, 0xd9, 0x80, 0x4d, 0x8f, 0x58, 0x4b, 0xa9, 0x29, 0x02, 0x86, 0xd7, 0x27, 0x21, 0xfb,
	0x68, 0x93, 0x8d, 0x9f, 0xf2, 0xb0, 0xd6, 0xa6, 0x3a, 0x52, 0x61, 0x6b, 0xaa, 0xa3, 0xdb, 0x9f,
	0x6e, 0x33, 0xa6, 0x3b, 0x2c, 0xf1, 0x5a, 0x9a, 0x95, 0x0b, 0x8a, 0xc2, 0xe5, 0xb9, 0x8d, 0x07,
	0xba, 0x11, 0x5f, 0x9e, 0xd2, 0xa2, 0x89, 0xb5, 0xa5, 0xc0, 0x3c, 0xa8, 0x0e, 0xef, 0xce, 0x3c,
	0xd9, 0xe8, 0xa3, 0xb8, 0x8f, 0x84, 0x36, 0x45, 0xbc, 0xbe, 0x10, 0xc8, 0x03, 0x0d, 0xe0, 0x72,
	0x8c, 0xdc, 0x30, 0xd8, 0xcd, 0x99, 0x84, 0x53, 0x5a, 0x04, 0x51, 0x5e, 0x0e, 0xcd, 0xc3, 0x1a,
	0xb0, 0x75, 0x42, 0x18, 0x7f, 0x58, 0xd1, 0x51, 0x7c, 0x7d, 0x72, 0x0b, 0x20, 0xde, 0x5c, 0x06,
	0xcb, 0x23, 0x3d, 0x03, 0x31, 0xf9, 0x99, 0x46, 0xb7, 0xe2, 0xbe, 0x16, 0x3d, 0xe9, 0xe2, 0xd1,
	0xe2, 0x15, 0x3c, 0xf6, 0x08, 0xf6, 0x12, 0x0a, 0x3f, 0x9a, 0xd1, 0x43, 0xea, 0x0b, 0x27, 0x2a,
	0x4b, 0xc2, 0x79, 0xe8, 0x1f, 0x04, 0x90, 0x16, 0x57, 0x4d, 0xf4, 0x69, 0x82, 0xdf, 0x85, 0x2f,
	0x90, 0x78, 0xe7, 0xdf, 0xaf, 0xe4, 0xc9, 0x0d, 0xe1, 0xfd, 0xf9, 0x55, 0x6b, 0x8e, 0xea, 0x52,
	0x8a, 0xf3, 0x1c, 0xd5, 0xa5, 0xd6, 0xc2, 0xf1, 0x79, 0x24, 0x54, 0x92, 0xd9, 0xf3, 0x48, 0x2d,
	0x98, 0xb3, 0xe7, 0xb1, 0xa0, 0x42, 0x89, 0xeb, 0x5f, 0xbd, 0x79, 0x71, 0x24, 0xb4, 0x8e, 0x5f,
	0x9d, 0x96, 0x85, 0xd7, 0xa7, 0x65, 0xe1, 0xef, 0xd3, 0xb2, 0xf0, 0xdd, 0x59, 0x39, 0xf3, 0xfa,
	0xac, 0x9c, 0xf9, 0xf3, 0xac, 0x9c, 0x79, 0x74, 0x5b, 0x37, 0x99, 0x31, 0xe8, 0xca, 0x3d, 0xc7,
	0x52, 0xee, 0x61, 0x32, 0x6c, 0x9b, 0xcc, 0xf0, 0xb0, 0x1d, 0xfe, 0xb5, 0xd6, 0x2c, 0x47, 0x1b,
	0xf4, 0x09, 0x55, 0x9e, 0x2a, 0xfc, 0x17, 0x98, 0x8d, 0x5c, 0x42, 0xbb, 0x1b, 0xfe, 0xa3, 0xfa,
	0xf1, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xa5, 0x14, 0x9a, 0x56, 0x8d, 0x0f, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// UpdateParams defines a governance operation for updating the parameters.
	//
	// Since: cosmos-sdk 0.47
	UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	// Multisig account
	CreateMultisigAccount(ctx context.Context, in *MsgCreateMultisigAccountParams, opts ...grpc.CallOption) (*MsgCreateMultisigAccountResponse, error)
	AddMultisigSigner(ctx context.Context, in *MsgAddMultisigSignerParams, opts ...grpc.CallOption) (*MsgAddMultisigSignerResponse, error)
	CleanupMultisigSigner(ctx context.Context, in *MsgCleanupMultisigAccountParams, opts ...grpc.CallOption) (*MsgCleanupMultisigAccountResponse, error)
	SetThreshold(ctx context.Context, in *MsgSetMultisigThresholdParams, opts ...grpc.CallOption) (*MsgSetMultisigThresholdResponse, error)
	InitializeMultisigProposal(ctx context.Context, in *MsgInitializeMultisigProposalParams, opts ...grpc.CallOption) (*MsgInitializeMultisigResponse, error)
	ApproveMultisigProposal(ctx context.Context, in *MsgApproveMultisigProposalParams, opts ...grpc.CallOption) (*MsgApproveMultisigProposalResponse, error)
	ApproveAndDispatchMultisigProposal(ctx context.Context, in *MsgApproveAndDispatchMultisigProposalParams, opts ...grpc.CallOption) (*MsgApproveAndDispatchMultisigProposalResponse, error)
	CancelMultisigProposal(ctx context.Context, in *MsgCancelMultisigProposalParams, opts ...grpc.CallOption) (*MsgCancelMultisigProposalResponse, error)
	CleanupMultisigProposal(ctx context.Context, in *MsgCleanupMultisigProposalParams, opts ...grpc.CallOption) (*MsgCleanupMultisigProposalResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/multisig.v1.Msg/UpdateParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateMultisigAccount(ctx context.Context, in *MsgCreateMultisigAccountParams, opts ...grpc.CallOption) (*MsgCreateMultisigAccountResponse, error) {
	out := new(MsgCreateMultisigAccountResponse)
	err := c.cc.Invoke(ctx, "/multisig.v1.Msg/CreateMultisigAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AddMultisigSigner(ctx context.Context, in *MsgAddMultisigSignerParams, opts ...grpc.CallOption) (*MsgAddMultisigSignerResponse, error) {
	out := new(MsgAddMultisigSignerResponse)
	err := c.cc.Invoke(ctx, "/multisig.v1.Msg/AddMultisigSigner", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CleanupMultisigSigner(ctx context.Context, in *MsgCleanupMultisigAccountParams, opts ...grpc.CallOption) (*MsgCleanupMultisigAccountResponse, error) {
	out := new(MsgCleanupMultisigAccountResponse)
	err := c.cc.Invoke(ctx, "/multisig.v1.Msg/CleanupMultisigSigner", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetThreshold(ctx context.Context, in *MsgSetMultisigThresholdParams, opts ...grpc.CallOption) (*MsgSetMultisigThresholdResponse, error) {
	out := new(MsgSetMultisigThresholdResponse)
	err := c.cc.Invoke(ctx, "/multisig.v1.Msg/SetThreshold", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) InitializeMultisigProposal(ctx context.Context, in *MsgInitializeMultisigProposalParams, opts ...grpc.CallOption) (*MsgInitializeMultisigResponse, error) {
	out := new(MsgInitializeMultisigResponse)
	err := c.cc.Invoke(ctx, "/multisig.v1.Msg/InitializeMultisigProposal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ApproveMultisigProposal(ctx context.Context, in *MsgApproveMultisigProposalParams, opts ...grpc.CallOption) (*MsgApproveMultisigProposalResponse, error) {
	out := new(MsgApproveMultisigProposalResponse)
	err := c.cc.Invoke(ctx, "/multisig.v1.Msg/ApproveMultisigProposal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ApproveAndDispatchMultisigProposal(ctx context.Context, in *MsgApproveAndDispatchMultisigProposalParams, opts ...grpc.CallOption) (*MsgApproveAndDispatchMultisigProposalResponse, error) {
	out := new(MsgApproveAndDispatchMultisigProposalResponse)
	err := c.cc.Invoke(ctx, "/multisig.v1.Msg/ApproveAndDispatchMultisigProposal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CancelMultisigProposal(ctx context.Context, in *MsgCancelMultisigProposalParams, opts ...grpc.CallOption) (*MsgCancelMultisigProposalResponse, error) {
	out := new(MsgCancelMultisigProposalResponse)
	err := c.cc.Invoke(ctx, "/multisig.v1.Msg/CancelMultisigProposal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CleanupMultisigProposal(ctx context.Context, in *MsgCleanupMultisigProposalParams, opts ...grpc.CallOption) (*MsgCleanupMultisigProposalResponse, error) {
	out := new(MsgCleanupMultisigProposalResponse)
	err := c.cc.Invoke(ctx, "/multisig.v1.Msg/CleanupMultisigProposal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// UpdateParams defines a governance operation for updating the parameters.
	//
	// Since: cosmos-sdk 0.47
	UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)
	// Multisig account
	CreateMultisigAccount(context.Context, *MsgCreateMultisigAccountParams) (*MsgCreateMultisigAccountResponse, error)
	AddMultisigSigner(context.Context, *MsgAddMultisigSignerParams) (*MsgAddMultisigSignerResponse, error)
	CleanupMultisigSigner(context.Context, *MsgCleanupMultisigAccountParams) (*MsgCleanupMultisigAccountResponse, error)
	SetThreshold(context.Context, *MsgSetMultisigThresholdParams) (*MsgSetMultisigThresholdResponse, error)
	InitializeMultisigProposal(context.Context, *MsgInitializeMultisigProposalParams) (*MsgInitializeMultisigResponse, error)
	ApproveMultisigProposal(context.Context, *MsgApproveMultisigProposalParams) (*MsgApproveMultisigProposalResponse, error)
	ApproveAndDispatchMultisigProposal(context.Context, *MsgApproveAndDispatchMultisigProposalParams) (*MsgApproveAndDispatchMultisigProposalResponse, error)
	CancelMultisigProposal(context.Context, *MsgCancelMultisigProposalParams) (*MsgCancelMultisigProposalResponse, error)
	CleanupMultisigProposal(context.Context, *MsgCleanupMultisigProposalParams) (*MsgCleanupMultisigProposalResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) UpdateParams(ctx context.Context, req *MsgUpdateParams) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateParams not implemented")
}
func (*UnimplementedMsgServer) CreateMultisigAccount(ctx context.Context, req *MsgCreateMultisigAccountParams) (*MsgCreateMultisigAccountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMultisigAccount not implemented")
}
func (*UnimplementedMsgServer) AddMultisigSigner(ctx context.Context, req *MsgAddMultisigSignerParams) (*MsgAddMultisigSignerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddMultisigSigner not implemented")
}
func (*UnimplementedMsgServer) CleanupMultisigSigner(ctx context.Context, req *MsgCleanupMultisigAccountParams) (*MsgCleanupMultisigAccountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CleanupMultisigSigner not implemented")
}
func (*UnimplementedMsgServer) SetThreshold(ctx context.Context, req *MsgSetMultisigThresholdParams) (*MsgSetMultisigThresholdResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetThreshold not implemented")
}
func (*UnimplementedMsgServer) InitializeMultisigProposal(ctx context.Context, req *MsgInitializeMultisigProposalParams) (*MsgInitializeMultisigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitializeMultisigProposal not implemented")
}
func (*UnimplementedMsgServer) ApproveMultisigProposal(ctx context.Context, req *MsgApproveMultisigProposalParams) (*MsgApproveMultisigProposalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApproveMultisigProposal not implemented")
}
func (*UnimplementedMsgServer) ApproveAndDispatchMultisigProposal(ctx context.Context, req *MsgApproveAndDispatchMultisigProposalParams) (*MsgApproveAndDispatchMultisigProposalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApproveAndDispatchMultisigProposal not implemented")
}
func (*UnimplementedMsgServer) CancelMultisigProposal(ctx context.Context, req *MsgCancelMultisigProposalParams) (*MsgCancelMultisigProposalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelMultisigProposal not implemented")
}
func (*UnimplementedMsgServer) CleanupMultisigProposal(ctx context.Context, req *MsgCleanupMultisigProposalParams) (*MsgCleanupMultisigProposalResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CleanupMultisigProposal not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_UpdateParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/multisig.v1.Msg/UpdateParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateMultisigAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateMultisigAccountParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateMultisigAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/multisig.v1.Msg/CreateMultisigAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateMultisigAccount(ctx, req.(*MsgCreateMultisigAccountParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AddMultisigSigner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAddMultisigSignerParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AddMultisigSigner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/multisig.v1.Msg/AddMultisigSigner",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AddMultisigSigner(ctx, req.(*MsgAddMultisigSignerParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CleanupMultisigSigner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCleanupMultisigAccountParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CleanupMultisigSigner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/multisig.v1.Msg/CleanupMultisigSigner",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CleanupMultisigSigner(ctx, req.(*MsgCleanupMultisigAccountParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetThreshold_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetMultisigThresholdParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetThreshold(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/multisig.v1.Msg/SetThreshold",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetThreshold(ctx, req.(*MsgSetMultisigThresholdParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_InitializeMultisigProposal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgInitializeMultisigProposalParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).InitializeMultisigProposal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/multisig.v1.Msg/InitializeMultisigProposal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).InitializeMultisigProposal(ctx, req.(*MsgInitializeMultisigProposalParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ApproveMultisigProposal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgApproveMultisigProposalParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ApproveMultisigProposal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/multisig.v1.Msg/ApproveMultisigProposal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ApproveMultisigProposal(ctx, req.(*MsgApproveMultisigProposalParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ApproveAndDispatchMultisigProposal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgApproveAndDispatchMultisigProposalParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ApproveAndDispatchMultisigProposal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/multisig.v1.Msg/ApproveAndDispatchMultisigProposal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ApproveAndDispatchMultisigProposal(ctx, req.(*MsgApproveAndDispatchMultisigProposalParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CancelMultisigProposal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCancelMultisigProposalParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CancelMultisigProposal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/multisig.v1.Msg/CancelMultisigProposal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CancelMultisigProposal(ctx, req.(*MsgCancelMultisigProposalParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CleanupMultisigProposal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCleanupMultisigProposalParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CleanupMultisigProposal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/multisig.v1.Msg/CleanupMultisigProposal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CleanupMultisigProposal(ctx, req.(*MsgCleanupMultisigProposalParams))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "multisig.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateParams",
			Handler:    _Msg_UpdateParams_Handler,
		},
		{
			MethodName: "CreateMultisigAccount",
			Handler:    _Msg_CreateMultisigAccount_Handler,
		},
		{
			MethodName: "AddMultisigSigner",
			Handler:    _Msg_AddMultisigSigner_Handler,
		},
		{
			MethodName: "CleanupMultisigSigner",
			Handler:    _Msg_CleanupMultisigSigner_Handler,
		},
		{
			MethodName: "SetThreshold",
			Handler:    _Msg_SetThreshold_Handler,
		},
		{
			MethodName: "InitializeMultisigProposal",
			Handler:    _Msg_InitializeMultisigProposal_Handler,
		},
		{
			MethodName: "ApproveMultisigProposal",
			Handler:    _Msg_ApproveMultisigProposal_Handler,
		},
		{
			MethodName: "ApproveAndDispatchMultisigProposal",
			Handler:    _Msg_ApproveAndDispatchMultisigProposal_Handler,
		},
		{
			MethodName: "CancelMultisigProposal",
			Handler:    _Msg_CancelMultisigProposal_Handler,
		},
		{
			MethodName: "CleanupMultisigProposal",
			Handler:    _Msg_CleanupMultisigProposal_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "multisig/v1/tx.proto",
}

func (m *MsgUpdateParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgCreateMultisigAccountParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateMultisigAccountParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateMultisigAccountParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Permission != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Permission))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Signers) > 0 {
		for iNdEx := len(m.Signers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Signers[iNdEx])
			copy(dAtA[i:], m.Signers[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.Signers[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Threshold != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Threshold))
		i--
		dAtA[i] = 0x18
	}
	if m.Seed != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Seed))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateMultisigAccountResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateMultisigAccountResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateMultisigAccountResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MultisigAddress) > 0 {
		i -= len(m.MultisigAddress)
		copy(dAtA[i:], m.MultisigAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MultisigAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAddMultisigSignerParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddMultisigSignerParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddMultisigSignerParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XNewThreshold != nil {
		{
			size := m.XNewThreshold.Size()
			i -= size
			if _, err := m.XNewThreshold.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Signer) > 0 {
		i -= len(m.Signer)
		copy(dAtA[i:], m.Signer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Signer)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MultisigAddress) > 0 {
		i -= len(m.MultisigAddress)
		copy(dAtA[i:], m.MultisigAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MultisigAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAddMultisigSignerParams_NewThreshold) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddMultisigSignerParams_NewThreshold) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintTx(dAtA, i, uint64(m.NewThreshold))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *MsgAddMultisigSignerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddMultisigSignerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddMultisigSignerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgCleanupMultisigAccountParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCleanupMultisigAccountParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCleanupMultisigAccountParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MultisigAddress) > 0 {
		i -= len(m.MultisigAddress)
		copy(dAtA[i:], m.MultisigAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MultisigAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCleanupMultisigAccountResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCleanupMultisigAccountResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCleanupMultisigAccountResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSetMultisigThresholdParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetMultisigThresholdParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetMultisigThresholdParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Threshold != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Threshold))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MultisigAddress) > 0 {
		i -= len(m.MultisigAddress)
		copy(dAtA[i:], m.MultisigAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MultisigAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetMultisigThresholdResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetMultisigThresholdResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetMultisigThresholdResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgInitializeMultisigProposalParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgInitializeMultisigProposalParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgInitializeMultisigProposalParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Proposer) > 0 {
		i -= len(m.Proposer)
		copy(dAtA[i:], m.Proposer)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Proposer)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MultisigAddress) > 0 {
		i -= len(m.MultisigAddress)
		copy(dAtA[i:], m.MultisigAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MultisigAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgInitializeMultisigResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgInitializeMultisigResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgInitializeMultisigResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProposalId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgApproveMultisigProposalParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgApproveMultisigProposalParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgApproveMultisigProposalParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Approver) > 0 {
		i -= len(m.Approver)
		copy(dAtA[i:], m.Approver)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Approver)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ProposalId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MultisigAddress) > 0 {
		i -= len(m.MultisigAddress)
		copy(dAtA[i:], m.MultisigAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MultisigAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgApproveMultisigProposalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgApproveMultisigProposalResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgApproveMultisigProposalResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgApproveAndDispatchMultisigProposalParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgApproveAndDispatchMultisigProposalParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgApproveAndDispatchMultisigProposalParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTx(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Approver) > 0 {
		i -= len(m.Approver)
		copy(dAtA[i:], m.Approver)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Approver)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ProposalId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MultisigAddress) > 0 {
		i -= len(m.MultisigAddress)
		copy(dAtA[i:], m.MultisigAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MultisigAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgApproveAndDispatchMultisigProposalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgApproveAndDispatchMultisigProposalResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgApproveAndDispatchMultisigProposalResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TransactionHash) > 0 {
		i -= len(m.TransactionHash)
		copy(dAtA[i:], m.TransactionHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TransactionHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCancelMultisigProposalParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelMultisigProposalParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelMultisigProposalParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rejecter) > 0 {
		i -= len(m.Rejecter)
		copy(dAtA[i:], m.Rejecter)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Rejecter)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ProposalId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MultisigAddress) > 0 {
		i -= len(m.MultisigAddress)
		copy(dAtA[i:], m.MultisigAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MultisigAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCancelMultisigProposalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelMultisigProposalResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelMultisigProposalResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgCleanupMultisigProposalParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCleanupMultisigProposalParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCleanupMultisigProposalParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Remover) > 0 {
		i -= len(m.Remover)
		copy(dAtA[i:], m.Remover)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Remover)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ProposalId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MultisigAddress) > 0 {
		i -= len(m.MultisigAddress)
		copy(dAtA[i:], m.MultisigAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MultisigAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCleanupMultisigProposalResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCleanupMultisigProposalResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCleanupMultisigProposalResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgUpdateParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Params.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgCreateMultisigAccountParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Seed != 0 {
		n += 1 + sovTx(uint64(m.Seed))
	}
	if m.Threshold != 0 {
		n += 1 + sovTx(uint64(m.Threshold))
	}
	if len(m.Signers) > 0 {
		for _, b := range m.Signers {
			l = len(b)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.Permission != 0 {
		n += 1 + sovTx(uint64(m.Permission))
	}
	return n
}

func (m *MsgCreateMultisigAccountResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MultisigAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgAddMultisigSignerParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MultisigAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Signer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.XNewThreshold != nil {
		n += m.XNewThreshold.Size()
	}
	return n
}

func (m *MsgAddMultisigSignerParams_NewThreshold) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovTx(uint64(m.NewThreshold))
	return n
}
func (m *MsgAddMultisigSignerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgCleanupMultisigAccountParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MultisigAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCleanupMultisigAccountResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSetMultisigThresholdParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MultisigAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Threshold != 0 {
		n += 1 + sovTx(uint64(m.Threshold))
	}
	return n
}

func (m *MsgSetMultisigThresholdResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgInitializeMultisigProposalParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MultisigAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Proposer)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgInitializeMultisigResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalId != 0 {
		n += 1 + sovTx(uint64(m.ProposalId))
	}
	return n
}

func (m *MsgApproveMultisigProposalParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MultisigAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ProposalId != 0 {
		n += 1 + sovTx(uint64(m.ProposalId))
	}
	l = len(m.Approver)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgApproveMultisigProposalResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgApproveAndDispatchMultisigProposalParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MultisigAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ProposalId != 0 {
		n += 1 + sovTx(uint64(m.ProposalId))
	}
	l = len(m.Approver)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgApproveAndDispatchMultisigProposalResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TransactionHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCancelMultisigProposalParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MultisigAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ProposalId != 0 {
		n += 1 + sovTx(uint64(m.ProposalId))
	}
	l = len(m.Rejecter)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCancelMultisigProposalResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgCleanupMultisigProposalParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MultisigAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ProposalId != 0 {
		n += 1 + sovTx(uint64(m.ProposalId))
	}
	l = len(m.Remover)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCleanupMultisigProposalResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgUpdateParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateMultisigAccountParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateMultisigAccountParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateMultisigAccountParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seed", wireType)
			}
			m.Seed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seed |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			m.Threshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Threshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signers", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signers = append(m.Signers, make([]byte, postIndex-iNdEx))
			copy(m.Signers[len(m.Signers)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permission", wireType)
			}
			m.Permission = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Permission |= MultisigProposalType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateMultisigAccountResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateMultisigAccountResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateMultisigAccountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultisigAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MultisigAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddMultisigSignerParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddMultisigSignerParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddMultisigSignerParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultisigAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MultisigAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewThreshold", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.XNewThreshold = &MsgAddMultisigSignerParams_NewThreshold{v}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddMultisigSignerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddMultisigSignerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddMultisigSignerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCleanupMultisigAccountParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCleanupMultisigAccountParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCleanupMultisigAccountParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultisigAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MultisigAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCleanupMultisigAccountResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCleanupMultisigAccountResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCleanupMultisigAccountResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetMultisigThresholdParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetMultisigThresholdParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetMultisigThresholdParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultisigAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MultisigAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			m.Threshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Threshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetMultisigThresholdResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetMultisigThresholdResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetMultisigThresholdResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgInitializeMultisigProposalParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgInitializeMultisigProposalParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgInitializeMultisigProposalParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultisigAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MultisigAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &types.Any{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgInitializeMultisigResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgInitializeMultisigResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgInitializeMultisigResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgApproveMultisigProposalParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgApproveMultisigProposalParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgApproveMultisigProposalParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultisigAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MultisigAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Approver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Approver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgApproveMultisigProposalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgApproveMultisigProposalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgApproveMultisigProposalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgApproveAndDispatchMultisigProposalParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgApproveAndDispatchMultisigProposalParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgApproveAndDispatchMultisigProposalParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultisigAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MultisigAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Approver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Approver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &types.Any{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgApproveAndDispatchMultisigProposalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgApproveAndDispatchMultisigProposalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgApproveAndDispatchMultisigProposalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelMultisigProposalParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelMultisigProposalParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelMultisigProposalParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultisigAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MultisigAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rejecter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rejecter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelMultisigProposalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelMultisigProposalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelMultisigProposalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCleanupMultisigProposalParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCleanupMultisigProposalParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCleanupMultisigProposalParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultisigAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MultisigAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Remover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCleanupMultisigProposalResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCleanupMultisigProposalResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCleanupMultisigProposalResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
